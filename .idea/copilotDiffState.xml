<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/telemetri-sdk/src/main/java/com/commerin/telemetri/core/TelemetriSdk.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/telemetri-sdk/src/main/java/com/commerin/telemetri/core/TelemetriSdk.kt" />
              <option name="originalContent" value="package com.commerin.telemetri.core&#10;&#10;import android.Manifest&#10;import android.content.Context&#10;import androidx.annotation.RequiresPermission&#10;import androidx.lifecycle.LiveData&#10;import com.commerin.telemetri.domain.model.ComprehensiveTelemetryEvent&#10;import com.commerin.telemetri.core.TelemetryConfig&#10;&#10;class TelemetriSdk(private val context: Context) {&#10;    private val telemetriManager = TelemetriManager.getInstance(context)&#10;&#10;    @RequiresPermission(anyOf = [Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION])&#10;    fun startTracking(config: TelemetryConfig = TelemetryConfig()) {&#10;        telemetriManager.startTelemetryCollection(config)&#10;    }&#10;&#10;    fun stopTracking() {&#10;        telemetriManager.stopTelemetryCollection()&#10;    }&#10;&#10;    fun observeTelemetry(): LiveData&lt;ComprehensiveTelemetryEvent&gt; {&#10;        return telemetriManager.comprehensiveTelemetry&#10;    }&#10;&#10;    fun configureTelemetry(config: TelemetryConfig) {&#10;        telemetriManager.configureTelemetry(config)&#10;    }&#10;&#10;    fun cleanup() {&#10;        telemetriManager.cleanup()&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.commerin.telemetri.core&#10;&#10;import android.Manifest&#10;import android.content.Context&#10;import androidx.annotation.RequiresPermission&#10;import androidx.lifecycle.LiveData&#10;import com.commerin.telemetri.domain.model.ComprehensiveTelemetryEvent&#10;import com.commerin.telemetri.core.TelemetryConfig&#10;&#10;class TelemetriSdk(private val context: Context) {&#10;    private val telemetriManager = TelemetriManager.getInstance(context)&#10;&#10;    @RequiresPermission(anyOf = [Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION])&#10;    fun startTracking(config: TelemetryConfig = TelemetryConfig()) {&#10;        telemetriManager.startTelemetryCollection(config)&#10;    }&#10;&#10;    fun stopTracking() {&#10;        telemetriManager.stopTelemetryCollection()&#10;    }&#10;&#10;    fun observeTelemetry(): LiveData&lt;ComprehensiveTelemetryEvent&gt; {&#10;        return telemetriManager.comprehensiveTelemetry&#10;    }&#10;&#10;    fun configureTelemetry(config: TelemetryConfig) {&#10;        telemetriManager.configureTelemetry(config)&#10;    }&#10;&#10;    fun cleanup() {&#10;        telemetriManager.cleanup()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/telemetri-sdk/src/main/java/com/commerin/telemetri/data/location/LocationDataSource.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/telemetri-sdk/src/main/java/com/commerin/telemetri/data/location/LocationDataSource.kt" />
              <option name="originalContent" value="package com.commerin.telemetri.data.location&#10;&#10;import android.annotation.SuppressLint&#10;import android.content.Context&#10;import com.google.android.gms.location.*&#10;import kotlinx.coroutines.channels.awaitClose&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.callbackFlow&#10;&#10;class LocationDataSource(context: Context) {&#10;&#10;    private val fusedLocationClient = LocationServices.getFusedLocationProviderClient(context)&#10;&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    fun getLocationUpdates(intervalMs: Long = 5000L): Flow&lt;LocationRaw&gt; = callbackFlow {&#10;        val request = LocationRequest.Builder(Priority.PRIORITY_HIGH_ACCURACY, intervalMs).build()&#10;&#10;        val callback = object : LocationCallback() {&#10;            override fun onLocationResult(result: LocationResult) {&#10;                for (loc in result.locations) {&#10;                    trySend(LocationRaw(&#10;                        latitude = loc.latitude,&#10;                        longitude = loc.longitude,&#10;                        altitude = if (loc.hasAltitude()) loc.altitude else null,&#10;                        speed = if (loc.hasSpeed()) loc.speed else null,&#10;                        accuracy = if (loc.hasAccuracy()) loc.accuracy else null,&#10;                        bearing = if (loc.hasBearing()) loc.bearing else null,&#10;                        provider = loc.provider ?: &quot;fused&quot;,&#10;                        timestamp = loc.time&#10;                    ))&#10;                }&#10;            }&#10;        }&#10;&#10;        fusedLocationClient.requestLocationUpdates(request, callback, null)&#10;&#10;        awaitClose {&#10;            fusedLocationClient.removeLocationUpdates(callback)&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.commerin.telemetri.data.location&#10;&#10;import android.annotation.SuppressLint&#10;import android.content.Context&#10;import com.google.android.gms.location.*&#10;import kotlinx.coroutines.channels.awaitClose&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.callbackFlow&#10;&#10;class LocationDataSource(context: Context) {&#10;&#10;    private val fusedLocationClient = LocationServices.getFusedLocationProviderClient(context)&#10;&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    fun getLocationUpdates(intervalMs: Long = 5000L): Flow&lt;LocationRaw&gt; = callbackFlow {&#10;        val request = LocationRequest.Builder(Priority.PRIORITY_HIGH_ACCURACY, intervalMs).build()&#10;&#10;        val callback = object : LocationCallback() {&#10;            override fun onLocationResult(result: LocationResult) {&#10;                for (loc in result.locations) {&#10;                    trySend(LocationRaw(&#10;                        latitude = loc.latitude,&#10;                        longitude = loc.longitude,&#10;                        altitude = if (loc.hasAltitude()) loc.altitude else null,&#10;                        speed = if (loc.hasSpeed()) loc.speed else null,&#10;                        accuracy = if (loc.hasAccuracy()) loc.accuracy else null,&#10;                        bearing = if (loc.hasBearing()) loc.bearing else null,&#10;                        provider = loc.provider ?: &quot;fused&quot;,&#10;                        timestamp = loc.time&#10;                    ))&#10;                }&#10;            }&#10;        }&#10;&#10;        fusedLocationClient.requestLocationUpdates(request, callback, null)&#10;&#10;        awaitClose {&#10;            fusedLocationClient.removeLocationUpdates(callback)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/telemetri-sdk/src/main/java/com/commerin/telemetri/data/location/LocationRaw.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/telemetri-sdk/src/main/java/com/commerin/telemetri/data/location/LocationRaw.kt" />
              <option name="originalContent" value="package com.commerin.telemetri.data.location&#10;&#10;// Raw location data from the location provider - matches LocationData structure&#10;data class LocationRaw(&#10;    val latitude: Double,&#10;    val longitude: Double,&#10;    val altitude: Double?,      // meters above sea level&#10;    val speed: Float?,          // m/s&#10;    val accuracy: Float?,       // meters&#10;    val bearing: Float?,        // degrees&#10;    val provider: String,       // location provider (gps, network, fused, etc.)&#10;    val timestamp: Long         // epoch millis&#10;)&#10;" />
              <option name="updatedContent" value="package com.commerin.telemetri.data.location&#10;&#10;// Raw location data from the location provider - matches LocationData structure&#10;data class LocationRaw(&#10;    val latitude: Double,&#10;    val longitude: Double,&#10;    val altitude: Double?,      // meters above sea level&#10;    val speed: Float?,          // m/s&#10;    val accuracy: Float?,       // meters&#10;    val bearing: Float?,        // degrees&#10;    val provider: String,       // location provider (gps, network, fused, etc.)&#10;    val timestamp: Long         // epoch millis&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/telemetri-sdk/src/main/java/com/commerin/telemetri/data/sensors/SensorMapper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/telemetri-sdk/src/main/java/com/commerin/telemetri/data/sensors/SensorMapper.kt" />
              <option name="originalContent" value="package com.commerin.telemetri.data.sensors&#10;&#10;import com.commerin.telemetri.domain.model.SensorData&#10;import com.commerin.telemetri.domain.model.SensorType&#10;import android.hardware.Sensor&#10;&#10;object SensorMapper {&#10;    fun map(raw: SensorRaw): SensorData {&#10;        return SensorData(&#10;            sensorType = mapSensorType(raw.type),&#10;            values = raw.values,&#10;            accuracy = 0, // Default accuracy since SensorRaw doesn't have it&#10;            x = raw.values.getOrElse(0) { 0f },&#10;            y = raw.values.getOrElse(1) { 0f },&#10;            z = raw.values.getOrElse(2) { 0f },&#10;            timestamp = raw.timestamp&#10;        )&#10;    }&#10;&#10;    private fun mapSensorType(type: Int): SensorType {&#10;        return when (type) {&#10;            Sensor.TYPE_ACCELEROMETER -&gt; SensorType.ACCELEROMETER&#10;            Sensor.TYPE_GYROSCOPE -&gt; SensorType.GYROSCOPE&#10;            Sensor.TYPE_MAGNETIC_FIELD -&gt; SensorType.MAGNETOMETER&#10;            Sensor.TYPE_GRAVITY -&gt; SensorType.GRAVITY&#10;            Sensor.TYPE_LINEAR_ACCELERATION -&gt; SensorType.LINEAR_ACCELERATION&#10;            Sensor.TYPE_ROTATION_VECTOR -&gt; SensorType.ROTATION_VECTOR&#10;            Sensor.TYPE_GAME_ROTATION_VECTOR -&gt; SensorType.GAME_ROTATION_VECTOR&#10;            Sensor.TYPE_GEOMAGNETIC_ROTATION_VECTOR -&gt; SensorType.GEOMAGNETIC_ROTATION_VECTOR&#10;            Sensor.TYPE_AMBIENT_TEMPERATURE -&gt; SensorType.AMBIENT_TEMPERATURE&#10;            Sensor.TYPE_LIGHT -&gt; SensorType.LIGHT&#10;            Sensor.TYPE_PRESSURE -&gt; SensorType.PRESSURE&#10;            Sensor.TYPE_RELATIVE_HUMIDITY -&gt; SensorType.RELATIVE_HUMIDITY&#10;            Sensor.TYPE_SIGNIFICANT_MOTION -&gt; SensorType.SIGNIFICANT_MOTION&#10;            Sensor.TYPE_STEP_COUNTER -&gt; SensorType.STEP_COUNTER&#10;            Sensor.TYPE_STEP_DETECTOR -&gt; SensorType.STEP_DETECTOR&#10;            Sensor.TYPE_HEART_RATE -&gt; SensorType.HEART_RATE&#10;            Sensor.TYPE_PROXIMITY -&gt; SensorType.PROXIMITY&#10;            Sensor.TYPE_ACCELEROMETER_UNCALIBRATED -&gt; SensorType.ACCELEROMETER_UNCALIBRATED&#10;            Sensor.TYPE_GYROSCOPE_UNCALIBRATED -&gt; SensorType.GYROSCOPE_UNCALIBRATED&#10;            Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED -&gt; SensorType.MAGNETOMETER_UNCALIBRATED&#10;            else -&gt; SensorType.ACCELEROMETER // Default fallback&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.commerin.telemetri.data.sensors&#10;&#10;import com.commerin.telemetri.domain.model.SensorData&#10;import com.commerin.telemetri.domain.model.SensorType&#10;import android.hardware.Sensor&#10;&#10;object SensorMapper {&#10;    fun map(raw: SensorRaw): SensorData {&#10;        return SensorData(&#10;            sensorType = mapSensorType(raw.type),&#10;            values = raw.values,&#10;            accuracy = 0, // Default accuracy since SensorRaw doesn't have it&#10;            x = raw.values.getOrElse(0) { 0f },&#10;            y = raw.values.getOrElse(1) { 0f },&#10;            z = raw.values.getOrElse(2) { 0f },&#10;            timestamp = raw.timestamp&#10;        )&#10;    }&#10;&#10;    private fun mapSensorType(type: Int): SensorType {&#10;        return when (type) {&#10;            Sensor.TYPE_ACCELEROMETER -&gt; SensorType.ACCELEROMETER&#10;            Sensor.TYPE_GYROSCOPE -&gt; SensorType.GYROSCOPE&#10;            Sensor.TYPE_MAGNETIC_FIELD -&gt; SensorType.MAGNETOMETER&#10;            Sensor.TYPE_GRAVITY -&gt; SensorType.GRAVITY&#10;            Sensor.TYPE_LINEAR_ACCELERATION -&gt; SensorType.LINEAR_ACCELERATION&#10;            Sensor.TYPE_ROTATION_VECTOR -&gt; SensorType.ROTATION_VECTOR&#10;            Sensor.TYPE_GAME_ROTATION_VECTOR -&gt; SensorType.GAME_ROTATION_VECTOR&#10;            Sensor.TYPE_GEOMAGNETIC_ROTATION_VECTOR -&gt; SensorType.GEOMAGNETIC_ROTATION_VECTOR&#10;            Sensor.TYPE_AMBIENT_TEMPERATURE -&gt; SensorType.AMBIENT_TEMPERATURE&#10;            Sensor.TYPE_LIGHT -&gt; SensorType.LIGHT&#10;            Sensor.TYPE_PRESSURE -&gt; SensorType.PRESSURE&#10;            Sensor.TYPE_RELATIVE_HUMIDITY -&gt; SensorType.RELATIVE_HUMIDITY&#10;            Sensor.TYPE_SIGNIFICANT_MOTION -&gt; SensorType.SIGNIFICANT_MOTION&#10;            Sensor.TYPE_STEP_COUNTER -&gt; SensorType.STEP_COUNTER&#10;            Sensor.TYPE_STEP_DETECTOR -&gt; SensorType.STEP_DETECTOR&#10;            Sensor.TYPE_HEART_RATE -&gt; SensorType.HEART_RATE&#10;            Sensor.TYPE_PROXIMITY -&gt; SensorType.PROXIMITY&#10;            Sensor.TYPE_ACCELEROMETER_UNCALIBRATED -&gt; SensorType.ACCELEROMETER_UNCALIBRATED&#10;            Sensor.TYPE_GYROSCOPE_UNCALIBRATED -&gt; SensorType.GYROSCOPE_UNCALIBRATED&#10;            Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED -&gt; SensorType.MAGNETOMETER_UNCALIBRATED&#10;            else -&gt; SensorType.ACCELEROMETER // Default fallback&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/telemetri-sdk/src/main/java/com/commerin/telemetri/domain/model/MotionData.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/telemetri-sdk/src/main/java/com/commerin/telemetri/domain/model/MotionData.kt" />
              <option name="originalContent" value="package com.commerin.telemetri.domain.model&#10;&#10;// Activity recognition for context-aware telemetry&#10;enum class ActivityType {&#10;    STILL,                  // Device is stationary&#10;    WALKING,                // User is walking&#10;    RUNNING,                // User is running&#10;    CYCLING,                // User is cycling&#10;    IN_VEHICLE,             // User is in a vehicle&#10;    ON_FOOT,                // User is on foot (walking or running)&#10;    TILTING,                // Device is being tilted&#10;    UNKNOWN                 // Activity cannot be determined&#10;}&#10;&#10;// Enhanced motion data model for advanced analysis&#10;data class MotionData(&#10;    val accelerationMagnitude: Float,    // Overall acceleration magnitude&#10;    val gyroscopeMagnitude: Float,       // Overall rotation magnitude&#10;    val magneticFieldMagnitude: Float,   // Magnetic field strength&#10;    val linearAcceleration: Triple&lt;Float, Float, Float&gt;, // Linear acceleration (x,y,z)&#10;    val gravity: Triple&lt;Float, Float, Float&gt;,            // Gravity vector (x,y,z)&#10;    val rotationVector: FloatArray,      // Device orientation as quaternion&#10;    val activityType: ActivityType,      // Detected activity&#10;    val confidence: Float,               // Confidence in activity detection&#10;    val stepCount: Int,                  // Current step count&#10;    val stepFrequency: Float,            // Steps per minute&#10;    val timestamp: Long,&#10;&#10;    // Legacy properties for backward compatibility&#10;    val acceleration: Float? = accelerationMagnitude,  // m/s² magnitude&#10;    val rotationRate: Float? = gyroscopeMagnitude,     // rad/s magnitude&#10;    val isHardBrake: Boolean = false,&#10;    val isRapidAcceleration: Boolean = accelerationMagnitude &gt; 4.0f,&#10;    val isSharpTurn: Boolean = gyroscopeMagnitude &gt; 2.0f&#10;) {&#10;    override fun equals(other: Any?): Boolean {&#10;        if (this === other) return true&#10;        if (javaClass != other?.javaClass) return false&#10;        other as MotionData&#10;        return accelerationMagnitude == other.accelerationMagnitude &amp;&amp;&#10;               gyroscopeMagnitude == other.gyroscopeMagnitude &amp;&amp;&#10;               magneticFieldMagnitude == other.magneticFieldMagnitude &amp;&amp;&#10;               timestamp == other.timestamp &amp;&amp;&#10;               rotationVector.contentEquals(other.rotationVector)&#10;    }&#10;&#10;    override fun hashCode(): Int {&#10;        var result = accelerationMagnitude.hashCode()&#10;        result = 31 * result + gyroscopeMagnitude.hashCode()&#10;        result = 31 * result + timestamp.hashCode()&#10;        result = 31 * result + rotationVector.contentHashCode()&#10;        return result&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.commerin.telemetri.domain.model&#10;&#10;// Activity recognition for context-aware telemetry&#10;enum class ActivityType {&#10;    STILL,                  // Device is stationary&#10;    WALKING,                // User is walking&#10;    RUNNING,                // User is running&#10;    CYCLING,                // User is cycling&#10;    IN_VEHICLE,             // User is in a vehicle&#10;    ON_FOOT,                // User is on foot (walking or running)&#10;    TILTING,                // Device is being tilted&#10;    UNKNOWN                 // Activity cannot be determined&#10;}&#10;&#10;// Enhanced motion data model for advanced analysis&#10;data class MotionData(&#10;    val accelerationMagnitude: Float,    // Overall acceleration magnitude&#10;    val gyroscopeMagnitude: Float,       // Overall rotation magnitude&#10;    val magneticFieldMagnitude: Float,   // Magnetic field strength&#10;    val linearAcceleration: Triple&lt;Float, Float, Float&gt;, // Linear acceleration (x,y,z)&#10;    val gravity: Triple&lt;Float, Float, Float&gt;,            // Gravity vector (x,y,z)&#10;    val rotationVector: FloatArray,      // Device orientation as quaternion&#10;    val activityType: ActivityType,      // Detected activity&#10;    val confidence: Float,               // Confidence in activity detection&#10;    val stepCount: Int,                  // Current step count&#10;    val stepFrequency: Float,            // Steps per minute&#10;    val timestamp: Long,&#10;&#10;    // Legacy properties for backward compatibility&#10;    val acceleration: Float? = accelerationMagnitude,  // m/s² magnitude&#10;    val rotationRate: Float? = gyroscopeMagnitude,     // rad/s magnitude&#10;    val isHardBrake: Boolean = false,&#10;    val isRapidAcceleration: Boolean = accelerationMagnitude &gt; 4.0f,&#10;    val isSharpTurn: Boolean = gyroscopeMagnitude &gt; 2.0f&#10;) {&#10;    override fun equals(other: Any?): Boolean {&#10;        if (this === other) return true&#10;        if (javaClass != other?.javaClass) return false&#10;        other as MotionData&#10;        return accelerationMagnitude == other.accelerationMagnitude &amp;&amp;&#10;               gyroscopeMagnitude == other.gyroscopeMagnitude &amp;&amp;&#10;               magneticFieldMagnitude == other.magneticFieldMagnitude &amp;&amp;&#10;               timestamp == other.timestamp &amp;&amp;&#10;               rotationVector.contentEquals(other.rotationVector)&#10;    }&#10;&#10;    override fun hashCode(): Int {&#10;        var result = accelerationMagnitude.hashCode()&#10;        result = 31 * result + gyroscopeMagnitude.hashCode()&#10;        result = 31 * result + timestamp.hashCode()&#10;        result = 31 * result + rotationVector.contentHashCode()&#10;        return result&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>